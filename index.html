<style>
    body {
        margin: 0;
        padding: 0;
    }
</style>

<div id="container"></div>

<script type="x-shader/x-vertex" id="vertexshader">
    void main() {
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = 1.0;
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    void main() {
        gl_FragColor = vec4(1, 1, 1, 1);
    }
</script>

<script type="module">
    import Stats from 'http://mrdoob.github.io/stats.js/build/stats.module.js';
    import * as THREE from 'https://unpkg.com/three@0.127.0/build/three.module.js'
    import {OrbitControls} from 'https://unpkg.com/three@0.127.0/examples/jsm/controls/OrbitControls.js'

    let renderer,
        scene,
        camera,
        controls,
        stats;

    let particleSystem,
        uniforms,
        geometry;

    const radius = 100;
    const particles = 1000000;

    init();
    animate();

    function init() {

        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 500;

        scene = new THREE.Scene();

        //

        const shaderMaterial = new THREE.ShaderMaterial({
            vertexShader: document
                .getElementById('vertexshader')
                .textContent,
            fragmentShader: document
                .getElementById('fragmentshader')
                .textContent,
            depthTest: false
        });

        geometry = new THREE.BufferGeometry();

        const positions = [];
        for (let i = 0; i < particles; i++) {
            positions.push((Math.random() * 2 - 1) * radius);
            positions.push((Math.random() * 2 - 1) * radius);
            positions.push((Math.random() * 2 - 1) * radius);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        particleSystem = new THREE.Points(geometry, shaderMaterial);

        scene.add(particleSystem);

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        const container = document.getElementById('container');
        container.appendChild(renderer.domElement);

        stats = new Stats();
        container.appendChild(stats.dom);

        // controls

        controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window);

        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        controls.screenSpacePanning = false;

        controls.minDistance = 10;
        controls.maxDistance = 1000;

        controls.maxPolarAngle = Math.PI / 2;

        //

        window.addEventListener('resize', onWindowResize);

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
        stats.update();
        controls.update();
    }

    function render() {
        const time = Date.now() * 0.005;
        particleSystem.rotation.y = 0.01 * time;

        renderer.render(scene, camera);
    }

    function processObj(lines) {

        const positions = geometry.attributes.position.array;

        let i = 0;
        let count = 0;

        lines.forEach((line) => {
            if (line.substr(0, 2) == "v ") {

                let data = line
                    .split(" ")
                    .filter((element) => {
                        return element.length != 0
                    });
                positions[i++] = (data[1] * radius);
                positions[i++] = (data[2] * radius);
                positions[i++] = (data[3] * radius);

                count++;
            }
        });

        console.log(count);

        geometry.attributes.position.needsUpdate = true;
        geometry.drawRange.count = count;

    }

    //

    let dropElement = document.getElementById("container");

    dropElement.addEventListener('dragover', (event) => {
        event.stopPropagation();
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
    }, false);

    dropElement.addEventListener('drop', async (event) => {

        event.stopPropagation();
        event.preventDefault();

        //

        let files = event.dataTransfer.files;
        let file = files[0];
        if (file.name.split('.')[1] == "obj") {}

        //

        let fileReader = new FileReader();

        fileReader.onload = (function (file) {
            return function (event) {
                let text = event.target.result;
                let lines = text.split(/[\r\n]+/g);
                processObj(lines);
            };
        })(file);

        //

        fileReader.readAsText(file);

    }, false);
</script>

<script></script>